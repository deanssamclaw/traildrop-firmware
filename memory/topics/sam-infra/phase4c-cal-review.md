# Phase 4c Cal Review: GPS + Waypoint Payload

Reviewed: 2026-03-01
Commit: 7f175d7
Files reviewed: `src/msg/waypoint.h`, `src/msg/waypoint.cpp`, `src/main_test.cpp`, `tests/phase4c_test_vectors.py`
Cross-referenced: Phase 4b Cal review, `src/msg/msgpack.h`, `src/msg/msgpack.cpp`, `src/msg/lxmf_transport.h`, `src/msg/lxmf_transport.cpp`, `src/msg/lxmf.h`, `src/hal/gps.h`

---

## 1. Buffer Overflows in waypoint_encode/decode

### 1a. custom_data[256] in waypoint_send_explicit (waypoint.cpp:117) — SAFE

The encode buffer is `uint8_t custom_data[256]`. Maximum encoded waypoint payload (name=31 chars, notes=127 chars, max uint32 timestamp) is **220 bytes** (verified with Python msgpack). 220 < 256. The Encoder sets `error=true` on overflow and `waypoint_encode` returns 0 (waypoint.cpp:39), so even if the estimate is wrong, no memory corruption occurs. **No issue.**

### 1b. Decoder key buffer: char key[16] (waypoint.cpp:57) — SAFE but fragile

The decoder reads map keys into `char key[16]`, passing `sizeof(key) - 1 = 15` as max_len to `read_str`. All current keys are short ("lat"=3, "lon"=3, "ele"=3, "name"=4, "notes"=5, "ts"=2). If a future protocol version adds a key longer than 15 chars, `read_str` sets `error=true` and the decode fails entirely — no partial decode, no overflow. **Safe but unnecessarily restrictive.** Consider `char key[32]` for forward compatibility.

### 1c. Decoder string field buffers — SAFE

`wp.name` = 32 bytes, read with `sizeof(wp.name) - 1 = 31` max. `wp.notes` = 128 bytes, read with `sizeof(wp.notes) - 1 = 127` max. The msgpack `read_str` implementation **rejects** (sets error, returns 0) if the encoded string exceeds max_len — no truncation, no overflow. If a peer sends a name longer than 31 bytes, the entire waypoint decode fails. This is the right behavior for firmware.

### 1d. Encoder strlen safety — SAFE in current usage

`waypoint_encode` calls `strlen(wp.name)` and `strlen(wp.notes)`. If a caller fails to null-terminate these fields, `strlen` reads past the buffer. However, all call sites use `memset(&wp, 0, sizeof(wp))` + `strncpy(field, src, sizeof(field) - 1)`, ensuring null termination. **Safe in current usage**, but fragile if future callers skip `memset`.

---

## 2. Double Precision: lat/lon as float64

### 2a. Encoder — CORRECT

`waypoint_encode` calls `enc.write_float64(wp.lat)` and `enc.write_float64(wp.lon)`. Verified in `msgpack.cpp`: `write_float64` emits `0xcb` prefix + 8 bytes big-endian IEEE 754 double via `memcpy` from `double` to `uint64_t` + `write_be64`. **True float64 on the wire, no precision loss.**

### 2b. Elevation encoded as float64 — INTENTIONAL but wasteful

`enc.write_float64((double)wp.ele)` casts the `float ele` to double before encoding. This uses 9 bytes instead of 5 (float32 = `0xca` + 4 bytes). For elevation in meters, float32 gives ~7 significant digits — more than sufficient.

**Impact**: 4 extra bytes per waypoint. At LoRa data rates this is meaningful (~32ms extra airtime at SF7/125kHz). Python `msgpack.packb` with `267.0` produces float64 by default, so this maintains byte-for-byte compatibility with the Python test vectors. The decision is defensible.

### 2c. Decoder — CORRECT, handles both widths

`dec.read_float64()` handles both `0xcb` (float64) and `0xca` (float32, promoted to double). Elevation is then narrowed: `wp.ele = (float)dec.read_float64()`. This means a future encoder could use float32 for elevation and the decoder would still work. **Forward-compatible.**

### 2d. Python byte-for-byte verification — CONFIRMED

The test `test_waypoint_encode_python_match` compares firmware output against the hex string generated by `phase4c_test_vectors.py`. Both the full-waypoint and no-notes vectors are verified with `memcmp`. **Encoding is interop-correct.**

### 2e. GPS HAL types — CORRECT chain

GPS HAL returns `double` for lat/lon and `float` for altitude (verified in `hal/gps.h`). Types match the Waypoint struct exactly:
```
gps_latitude()  → wp.lat  (double → double)  ✓ no precision loss
gps_longitude() → wp.lon  (double → double)  ✓ no precision loss
gps_altitude()  → wp.ele  (float → float)    ✓ no precision loss
```

---

## 3. The waypoint_send Flow

### 3a. GPS HAL → waypoint struct → msgpack — CORRECT

`waypoint_send` (waypoint.cpp:84-98) checks `gps_has_fix()` first, refuses with clear message if no fix. Delegates to `waypoint_send_explicit` which:
1. `memset(&wp, 0, sizeof(wp))` — zeroes all fields ✓
2. Copies lat/lon/ele from parameters ✓
3. `strncpy` for name/notes with null-termination guaranteed by memset ✓
4. Calls `waypoint_encode` into `custom_data[256]` ✓
5. Calls `lxmf_send` with custom_type="traildrop/waypoint" ✓

### 3b. LXMF custom fields → encrypted transport — CORRECT but REDUNDANT

`waypoint_send_explicit` passes:
- `name` as LXMF **title**
- `notes` as LXMF **content**
- `"traildrop/waypoint"` as custom_type (18 bytes)
- encoded waypoint (which also contains name and notes) as custom_data

**The name and notes appear twice in the LXMF message** — once as human-readable title/content, once inside the msgpack custom_data. This provides a fallback for receivers that don't understand `traildrop/waypoint`, but doubles the text payload.

For the typical case ("Waypoint" + "Shared from TrailDrop" = 29 chars duplicated), the redundancy adds ~30 bytes. Total LXMF = ~237 bytes, well within the 383-byte MDU. The design trades bandwidth for interop. **Acceptable, but this duplication is the primary reason long notes exceed the MDU limit (see section 5).**

### 3c. Receive path (main_test.cpp:1713-1727) — CORRECT

The `on_lxmf_received` callback correctly:
1. Checks `has_custom_fields` and `custom_type == "traildrop/waypoint"` with both length check (==18) and `memcmp`
2. Decodes waypoint from `custom_data` / `custom_data_len`
3. Prints all fields on success, logs failure on decode error
4. Falls through to regular LXMF display for non-waypoint messages

### 3d. 's' key handler (main_test.cpp:2749-2758) — CORRECT

Checks `gps_has_fix()` first, refuses with clear message. Looks up first peer, calls `waypoint_send`. **Phase 4b custom_type_len=19 bug resolved by design** — now delegates to `waypoint_send` which always uses 18.

### 3e. **BUG: Timestamp is uptime, not Unix time (LOW-MEDIUM)**

`waypoint_send_explicit` (waypoint.cpp:115):
```cpp
wp.timestamp = (uint32_t)(millis() / 1000);  // Uptime as placeholder
```

The struct comment says "Unix timestamp (seconds)" and test vectors use `1709312400` (a real Unix timestamp). But `millis() / 1000` gives seconds since boot, not epoch time. The comment says "placeholder," so this is presumably known.

**Impact**: Receivers cannot meaningfully interpret the timestamp. Waypoints from different boots have overlapping timestamp values. The field name "ts" and Python test value imply Unix time to any interop partner.

**Recommendation**: Either (a) set `ts=0` to explicitly signal "no real time available," or (b) document in the protocol that ts is uptime until RTC/GPS-UTC is available. The current code silently produces a misleading value.

---

## 4. Decoder Robustness

### 4a. Truncated input — SAFE

The Decoder tracks `pos` against `len`. Every `read_byte`/`read_bytes` checks bounds and sets `error=true` if insufficient data. The decode loop checks `if (dec.error) return false` after each field. A truncated message causes a clean failure. **No crash, no out-of-bounds read.**

### 4b. Malformed map header — SAFE

`read_map()` accepts fixmap (0x80-0x8f) and map16 (0xde). Any other tag sets `error=true`, returns 0. The `map_count < 4` check then rejects it. **No issue.**

### 4c. Wrong value types — SAFE

If a key "lat" has a string value instead of float64, `read_float64()` sees a non-0xcb/0xca tag, sets error. Loop exits. **Clean failure.**

### 4d. Unknown keys — SAFE

`dec.skip()` handles all msgpack types including nested maps/arrays (recursive). Verified in `msgpack.cpp` — covers fixint, fixmap, fixarray, fixstr, nil, bool, bin8/16/32, ext8/16/32, float32/64, uint8/16/32/64, int8/16/32/64, fixext, str8/16/32, array16/32, map16/32, negative fixint. **Comprehensive.** A waypoint from a newer firmware version with extra fields will decode successfully, ignoring the unknown fields. **Good design.**

**Latent issue in skip()**: Several code paths use `pos += n` then check `if (pos > len)` afterward, rather than pre-checking. If `pos + n` wraps `size_t`, the post-check would miss the overflow. Also, recursive calls for nested containers have no depth limit — a deeply nested structure could overflow the stack. **Severity: VERY LOW** for waypoints — data comes from encrypted+signed LXMF (max 256 bytes of custom_data), so attacker-crafted input requires breaking the crypto first. But the skip() implementation is a latent hazard for any future use with untrusted input.

### 4e. **Missing required-field validation — gap (LOW-MEDIUM)**

After the decode loop, `wp.valid = true` is set unconditionally (waypoint.cpp:80). The only guard is `map_count < 4`, which is also too lenient — the minimum valid waypoint has 5 required fields (lat, lon, ele, name, ts), so the check should be `< 5`. A malformed message with 5 fields but none matching "lat", "lon", etc. would produce:
```
wp.lat = 0.0, wp.lon = 0.0, wp.ele = 0.0, wp.name = "", wp.timestamp = 0, wp.valid = true
```

This is a "valid" waypoint at Null Island (0°, 0°) in the Gulf of Guinea. Any consumer checking `wp.valid` would trust it.

**Recommendation**: Track which required fields were actually populated:
```cpp
bool got_lat = false, got_lon = false;
// ... in the loop: got_lat = true; etc.
wp.valid = got_lat && got_lon;
```

At minimum, lat and lon should be required for `valid = true`.

### 4f. Extremely large map_count — SAFE

If a crafted message declares `map_count = 255` but only has 3 entries, the loop hits end of buffer, sets error, returns false. The `read_map` return type is `uint8_t` (max 255). For map16 with count > 255, it sets error. **No infinite loop, no allocation.**

### 4g. Zero-length data — SAFE

`waypoint_decode(data, 0, wp)`: `read_map` calls `read_byte` which sees `pos >= len` (0 >= 0), sets error. Returns false. **Clean.**

---

## 5. LXMF Size Budget with Waypoints

### Max waypoint vs. 383-byte MDU — correctly rejected by Phase 4b pre-check

With maximum-length fields (name=31, notes=127), the total LXMF message before encryption is **~497 bytes**, exceeding the 383-byte MDU by 114 bytes. The Phase 4b pre-check (`if (lxmf_len > 383) return false`) correctly prevents buffer overflow.

General formula (name ≤ 31, notes > 31): `LXMF = 245 + 2 × notes_len` (name and notes appear twice due to duplication in section 3b).

| Scenario | custom_data | packed_payload | LXMF total | Fits in 383? |
|----------|-------------|---------------|------------|-------------|
| Typical ("Waypoint", "Shared from TrailDrop") | 90 | 160 | 240 | YES |
| Medium name (15), notes (50) | 127 | 233 | 313 | YES |
| Max name (31), notes (50) | 143 | 265 | 345 | YES |
| Max name (31), notes (69) | 162 | 303 | 383 | YES — exact limit |
| Max name (31), notes (70) | 163 | 305 | 385 | **NO — rejected** |
| Max name (31), no notes | 85 | 157 | 237 | YES |

(Verified with Python msgpack: `LXMF = 245 + 2 × notes_len` for max name.)

The boundary is: with max name (31 chars), notes ≤ 69 chars fits; notes ≥ 70 chars is rejected. The 2× factor from duplication (section 3b) is the primary reason — without it, notes could be ~169 chars (`LXMF = 214 + notes_len`).

### **Missing failure log in waypoint_send_explicit (LOW)**

When `lxmf_send` returns false (MDU exceeded), there's no log output from `waypoint_send_explicit` — only the deep `[LXMF-TX] ERROR` message. The function silently returns false. Add:
```cpp
if (ok) {
    Serial.printf("[WAYPOINT] Sent: %s (%.6f, %.6f, %.1fm)\n", wp.name, wp.lat, wp.lon, wp.ele);
} else {
    Serial.println("[WAYPOINT] Send failed (message may exceed size limit)");
}
```

---

## 6. Test Coverage

### 6a. Test inventory (5 tests)

| Test | What it covers | Verdict |
|------|---------------|---------|
| `test_waypoint_encode_decode_roundtrip` | Encode all 7 fields → decode → verify each | Good — primary path |
| `test_waypoint_encode_python_match` | Byte-for-byte match vs Python msgpack hex | Excellent — interop proof |
| `test_waypoint_in_lxmf_roundtrip` | Encode → lxmf_build → parse → extract custom_data → decode | Excellent — full pipeline |
| `test_waypoint_no_gps_fix` | Encode/decode with zero coordinates | Adequate — see gap #3 |
| `test_waypoint_empty_notes` | Notes omitted (5-field map) → byte-match Python → decode | Good — conditional field |

### 6b. Missing tests (ordered by priority)

1. **No malformed input decoder tests (MEDIUM)** — The decoder's robustness (section 4) is comprehensive but untested. Should add at minimum:
   - Truncated payload (first 10 bytes of a valid encoding)
   - Wrong type for a value (string where float64 expected)
   - Map with 0 entries → expect decode failure

2. **No max-size waypoint rejection test (MEDIUM)** — A test with name=31 + notes=70 confirming `lxmf_send` rejects it (LXMF=385 > 383) would validate the MDU safety net. Also test notes=69 confirming it succeeds (LXMF=383, exact limit).

3. **test_waypoint_no_gps_fix is misnamed (LOW)** — Tests encode/decode of zero coords, not the actual `waypoint_send` GPS refusal path (waypoint.cpp:89). Can't mock `gps_has_fix()` on device. The test is still useful but the name is misleading.

4. **No unknown-key skip test (LOW)** — The `skip()` call in the decoder is present and comprehensive, but no test exercises forward-compatible decoding with extra unknown keys.

5. **No oversized-string rejection test (LOW)** — A peer sending name > 31 bytes causes full decode failure. Correct behavior but untested.

6. **Python test vector script lacks self-validation (LOW)** — The script generates hex but doesn't assert it matches expected values. Add `assert packed_full.hex() == "86a36c6174..."` for a two-way interop contract.

---

## 7. Phase 4b Review Items — VERIFIED FIXED

All three items from the Phase 4b Cal review were addressed in commit 7ac78b1:

1. **encrypted[] buffer overflow pre-check**: `if (lxmf_len > 383) return false` added at lxmf_transport.cpp:102. Uses RNS ENCRYPTED_MDU (Option B as recommended). ✓
2. **Null guard on s_lxmf_dest**: `s_lxmf_dest &&` added at lxmf_transport.cpp:187. ✓
3. **custom_type length 19 → 18**: Fixed. Phase 4c's `waypoint_send` design makes this class of bug impossible — the length is always hardcoded alongside the string. ✓

---

## 8. Additional Findings

### 8a. write_bin(nullptr, 0) UB — STILL PRESENT (from Phase 4b review)

`lxmf_build` can call `enc.write_bin(custom_data, custom_data_len)` where `custom_data=nullptr` and `custom_data_len=0`. This flows to `memcpy(buf+pos, nullptr, 0)` — UB per C/C++ spec. Most implementations handle it, but sanitizers will flag it. **Severity: LOW.** Fix: guard with `if (len > 0)` in `write_bytes`.

### 8b. Explicit double cast is redundant — COSMETIC

```cpp
enc.write_float64((double)wp.ele);  // waypoint.cpp:26
```

C++ implicitly promotes `float` to `double` in function calls. The explicit cast is harmless but unnecessary.

---

## 9. Summary — Verdict

### Overall: PASS (clean)

Phase 4c is a well-implemented, compact module. The waypoint codec is correct: lat/lon use true float64 encoding with verified Python interop, string handling is bounds-checked at every level via the Encoder/Decoder error-flag pattern, and the decoder includes comprehensive `skip()` for forward-compatible unknown-key handling. The GPS HAL interface preserves full double precision for coordinates.

The Phase 4b must-fix (encrypted buffer overflow) was correctly addressed and now serves as the safety net preventing oversized waypoints from causing memory corruption. All three Phase 4b should-fix items have been resolved.

### No must-fix items

### Should-fix

1. **Add required-field validation in waypoint_decode** (section 4e) — `wp.valid = true` is unconditional. A malformed message with unrecognized-only keys produces a "valid" waypoint at (0°, 0°). Track `got_lat`/`got_lon` flags and require them for `valid = true`.

2. **Add failure log in waypoint_send_explicit** (section 5) — When `lxmf_send` returns false, there's no log from the waypoint layer. Add an else branch with a failure message for debugging.

3. **Add malformed-input decoder tests** (section 6b) — The decoder is robust, but that robustness is unverified by tests. At minimum: truncated payload, wrong value type.

### Nice-to-have

4. Add max-size waypoint rejection test (validates MDU boundary).
5. Add unknown-key skip test for forward-compatibility verification.
6. Fix `write_bin(nullptr, 0)` UB (carried from Phase 4b).
7. Rename `test_waypoint_no_gps_fix` to `test_waypoint_zero_coords_roundtrip`.
8. Add self-validation assertions to Python test vector script.
9. Consider encoding elevation as float32 to save 4 bytes per waypoint.

---

*Reviewed by Cal (firmware reviewer agent), 2026-03-01*
